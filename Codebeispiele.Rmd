---
title: "Visualisierungsbeispiele"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: true
    number_sections: false
    toc_depth: 2
    code_folding: hide
---



```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=TRUE)
```

---- 

# Balkendiagramme

## Statisches Balkendiagramm

Hier sieht man ein gewöhnliches Balkendiagramm mit vertauschten Axen.

```{r eval=FALSE}
library(tidyverse)

data <- read_csv("../Desktop/Landkreise_merged.csv")

data %>%
    filter(Jahr == 2017) %>%
    top_n(10, Arbeitslosenquote) %>%
    ggplot(aes(x = fct_reorder(Raumeinheit,
                               Arbeitslosenquote),
               y = Arbeitslosenquote)) +
    geom_bar(stat = "identity",
             fill = "#2e4964") +
    geom_text(aes(y = Arbeitslosenquote,
                  label = paste0(format(Arbeitslosenquote,
                                        big.mark = ".",
                                        decimal.mark = ","), "%")),
              nudge_y = 0.65,
              size = 3.2) +
    coord_flip() +
    labs(x = "",
         y = "",
         title = "Arbeitslosenquote in Deutschland",
         subtitle = "Landkreise und kreisfreie Städte mit der höchsten 
                     Arbeitslosenquote (2017)") +
    theme_minimal() +
    theme(plot.title.position = "plot")
```
<center>
![](images/Barchart_static.png){width=70%}
</center>



## Racing Bar Chart (animiert)

Hier wird ein sogenannter "Racing Bar Chart" gezeigt, bei dem sich Veränderungen
der Rangfolge zwischen Untersuchungseinheiten über die Zeit darstellen lassen.
Der Code sieht auf den ersten Blick relativ umständlich aus, lässt sich aber in
weiten Teilen übernehmen und individuell anpassen. Der hier verwendete Trick 
besteht darin, den Datensatz zu erweitern und zwischen ganzen Jahren 
Zwischenschritte zu erzeugen und die fehlenden Daten der darzustellenden 
Variable zu interpolieren. Im konkreten Anwendungsfall werden hierfür zwischen
den Ausprägungen der Jahresvariable (2000, 2001, 2002, etc.) in 0.1er Schritten
(2000.1, 2000.2, 2000.3, ...) Werte für das BIP interpoliert, die in der 
Animation flüssigere Übergänge erzeugen.

```{r eval=FALSE}
library(tidyverse)
library(gganimate)

data <- read_csv("../Desktop/Landkreise_merged.csv")

theme_set(theme_void())

plot <-
    data %>%
    select(Kennziffer, Raumeinheit, Jahr, BIP) %>%
    filter(!is.na(BIP),
           Raumeinheit %in% (data %>%
                                 filter(Jahr == max(Jahr)) %>%
                                 top_n(15, BIP) %>%
                                 pull(Raumeinheit))) %>%
    group_by(Jahr) %>%
    mutate(rank = min_rank(-BIP) * 1) %>%
    group_by(Raumeinheit) %>%
    complete(Jahr = full_seq(Jahr, .1)) %>%
    mutate(BIP = spline(x = Jahr, y = BIP, xout = Jahr)$y) %>%
    # Approx Interpolation für die Rangvariable (spline ist hier zu sprunghaft)
    mutate(rank = approx(x = Jahr, y = rank, xout = Jahr)$y) %>%
    ungroup() %>%
    ggplot(aes(rank, group = Raumeinheit, fill = as.factor(Raumeinheit),
               color = as.factor(Raumeinheit))) +
    geom_tile(aes(y = BIP / 2, height = BIP, width = 0.9),
              alpha = 0.8, color = NA) +
    geom_text(aes(y = BIP, label = paste0(format(round(BIP*1000,0), 
                                                 big.mark = ".", 
                                                 decimal.mark = ","), "€")),
              hjust = 0, nudge_y = 2) +
    geom_text(aes(y = 0, label = paste(Raumeinheit, " ")),
              vjust = 0.2, hjust = 1) +
    coord_flip(clip = "off", expand = FALSE) +
    scale_x_reverse() +
    guides(color = FALSE, fill = FALSE) +
    scale_fill_viridis_d() +
    scale_color_viridis_d() +
    labs(title='BIP pro Landkreis {round(frame_time,0)}',
         subtitle = " ",
         x = "", y = "BIP (je Einwohner)") +
    theme(plot.title = element_text(hjust = -0.5, size = 20),
          axis.ticks.y = element_blank(),
          axis.text.y  = element_blank(),
          plot.margin = margin(1,2,1,6, "cm")) +
    transition_time(Jahr) +
    enter_grow() +
    exit_shrink() +
    ease_aes('cubic-in-out')

# nframes verlangsamt den Plot
animate(plot, fps = 20, width = 750, height = 450, nframes = 400)
anim_save('BIP.gif', animation = last_animation(), path = "../Desktop/")
```

<center>
![](images/BIP.gif)
</center>

---- 

# Boxplot

Von der Strutkur her ähnlich wie Balkendiagramme lassen sich mit <code>geom_boxplot()</code> einfach Boxplots erstellen, die aussagekräftiger sein können als Balkendiagramme. 

## Gewöhnlicher Boxplot

```{r eval=FALSE}
library(tidyverse)

# Einlesen der Beispieldaten
data <- read_csv("../Desktop/Landkreise_merged.csv")

data %>%
    filter(Jahr == 2017) %>%
    ggplot(aes(x = Aggregat, y = Durchschnittsalter,
               fill = Aggregat)) +
    geom_boxplot() +
    labs(x = "",
         y = "",
         title = "Durchschnittsalter in deutschen Landkreisen und kreisfreien Städten",
         subtitle = "N = 401; Jahr = 2017") +
    theme_minimal() +
    scale_fill_manual(values = c("#93a7bb", "#e0c599")) +
     theme(plot.title.position = "plot",
          legend.position = "none")

```
<center>
![](images/Boxplot.png){width=70%}
</center>

## Violinen-Plot

Eine Alternative zu Boxplots können Violinenplots darstellen, da hier auch 
die Verteilung der jeweiligen Variable dargestellt wird.

```{r eval=FALSE}
library(tidyverse)

# Einlesen der Beispieldaten
data <- read_csv("../Desktop/Landkreise_merged.csv")

data %>%
    filter(Jahr == 2017) %>%
    ggplot(aes(x = Aggregat, y = Durchschnittsalter,
               fill = Aggregat)) +
    geom_violin() +
    labs(x = "",
         y = "",
         title = "Durchschnittsalter in deutschen Landkreisen und kreisfreien Städten",
         subtitle = "N = 401; Jahr = 2017") +
    theme_minimal() +
    scale_fill_manual(values = c("#93a7bb", "#e0c599")) +
     theme(plot.title.position = "plot",
          legend.position = "none")

```
<center>
![](images/Violin.png){width=70%}
</center>


# Statische Karten

Hier visualisieren wir die Arbeitslosenquote in den 401 deutschen Kreisen und kreisfreien Städten auf einer Karte.

## Kontinuierlich

```{r eval=FALSE}
library(tidyverse)
library(ggthemes)
library(sf)
library(Hmisc)

data <- read_csv("daten_beispiele/Landkreise_merged.csv") %>% 
  filter(Jahr == 2017)

shapefile <- st_read("daten_beispiele/shapefiles_kreise/Kreisgrenzen_2017_mit_Einwohnerzahl.shp")

#Daten und Shapefile zusammenführen
data_merged <- shapefile %>% 
  left_join(data, by = c("RS" = "Kennziffer")) 
    
data_merged %>% 
  ggplot(aes(fill = Arbeitslosenquote/100)) +
  geom_sf() +
  scale_fill_gradient(low = "white", high = "#2e4964", guide = "colorbar", labels = scales::percent_format(accuracy = 2)) +
  theme_map() +
  theme(legend.title = element_blank(),
        legend.position = c(1.1, 0.3),
        legend.justification = c("right", "top")) +
   labs(title= "Arbeitslosenquote in Deutschland",
         subtitle = "2017, in Prozent")

ggsave("images/Arbeitslosenquote_2017_kontinuierlich.png")

```

<center>
![](images/Arbeitslosenquote_2017_kontinuierlich.png){width=70%}
</center>

## Gruppiert

In der gruppierten Variante teilen wir die 401 Kreise in 6 Gruppen, die wir dann entsprechend visualisieren. Im Unterschied zum vorherigen Beispiel müssen wir lediglich einige Strings manipulieren, um die entsprechenden Gruppen zu erstellen und die deutsche Kommaregel zu beachten.

```{r eval=FALSE}
library(tidyverse)
library(ggthemes)
library(sf)
library(Hmisc)

data <- read_csv("daten_beispiele/Landkreise_merged.csv") %>% 
  filter(Jahr == 2017) %>% 
  mutate(Gruppen_Arbeitslosenquote = Hmisc::cut2(Arbeitslosenquote, g = 6)) %>% 
  mutate(Gruppen_Arbeitslosenquote = str_replace_all(Gruppen_Arbeitslosenquote, "\\,", " -")) %>% 
  mutate(Gruppen_Arbeitslosenquote = str_replace_all(Gruppen_Arbeitslosenquote, "\\.", "\\,")) %>% 
  group_by(Gruppen_Arbeitslosenquote) %>% 
  mutate(observations = n()) %>% 
  ungroup() %>% 
  mutate(Gruppenbezeichnung = paste(Gruppen_Arbeitslosenquote, ", n = ", observations, sep = ""))

shapefile <- st_read("daten_beispiele/shapefiles_kreise/Kreisgrenzen_2017_mit_Einwohnerzahl.shp")

data_merged <- shapefile %>% 
  left_join(data, by = c("RS" = "Kennziffer")) 

#IW-Farbschema 
meine_IW_Farben <- c("#ca9c4d", "#e0c599", "#f3e2c5", "#93a7bb", "#748a9d", "#2e4964")
    
data_merged %>% 
  ggplot(aes(fill = Gruppenbezeichnung)) +
  geom_sf() +
  scale_fill_manual(values = meine_IW_Farben) +
  theme_map() +
  theme(legend.title = element_blank(),
        legend.position = c(1.1, 0.3),
        legend.justification = c("right", "top")) +
   labs(title= "Arbeitslosenquote in Deutschland",
         subtitle = "2017, in Prozent")

ggsave("images/Arbeitslosenquote_gruppiert_2017.png")
```

<center>
![](images/Arbeitslosenquote_gruppiert_2017.png){width=70%}
</center>
