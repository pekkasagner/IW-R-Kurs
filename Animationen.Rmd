---
title: "Animationen"
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: true
    number_sections: false
    toc_depth: 2
    #code_folding: hide
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(message=FALSE,warning=FALSE, cache=F)
```

----

# Ziele der Sitzung

* Erstellen von Animationen

Die Visualisierung von Daten ist ein wichtiges Instrument in der Kommunikation von Forschungsergebnissen. Statische Abbildungen sind in 99 % der Arbeit der angebrachte Weg. Wissenschaftliche Papiere sind eben immer noch weitestgehend für das Papierformat gedacht. Schon lange weden Forschungsergebnisse jedoch auch online veröffentlicht. Für die Einbettung auf Websites und insbesondere auch in Social-Media-Kanälen bieten animierte Abbildungen eine alternative zu statischen Abbildungen.

* Warum Animationen?

Mit animierten Abbildungen lassen sich insbesondere *Zustandsveränderungen* eindrucksvoll darstellen.

*Zustandsveränderungen* können zum Beispiel Veränderungen einer Variable über die Zeit sein. 

Ein weiteres Beispiel könnte die Visualisierung einer Regression sein, in der die Gruppenzugehörigkeit für ein Individuum geschätzt wird. Die Animation könnte Differenzen zwischen tatsächlicher und im Modell geschätzter Zugehörigkeit visualisieren. 

Auch Simulationsergebnissen könnten in spannender Weise visualisiert werden. Eine Animation könnte die Simulationsergebnisse für verschiedene Modellparameter darstellen. 

Wie bei der Visualisierung statischer Abbildungen, setzt auch bei Animationen lediglich die Fantasie die Grenzen, solange einige Grundprinzipien in der Datenstruktur beachtet werden.

* Grundidee

![](images/Erstellung_Animationen.png)

Die Grundidee bei der Erstellung von Animationen ist die, dass für jeden Animationszustand, zum Beispiel Zeitpunkt, eine eigene Abbildung erstellt wird. Grundvoraussetzung dafür ist, lediglich ein sauberes Datenformat. Soll beispielsweise der Zusammenhang von BIP pro Kopf und Arbeitslosenquote im Zeitverlauf für verschiedene Länder dargestellt werden braucht es genau vier Spalten: (1) BIP pro Kopf (2) Arbeitslosenquote (3) Jahr <-- *Animationszustand* (4) Land.

Das Paket <code>gganimate</code> übernimmt das (fast) alles.

Die Wahl des <code>geom</code> entspricht dabei in der Regel der Wahl, wenn nur eine statische Abbildung für einen Zeitpunkt erstellt würde.

----


### Benötigte Pakete

```{r}
library(tidyverse)
library(gganimate)
```

----

### Daten laden

```{r}
library(readr)
(Landkreise_merged <- read_csv("daten_beispiele/Landkreise_merged.csv")
)
```

Wir animieren die Entwicklung der Beziehung zwischen Arbeitslosenquote und BIP über die Zeit in den 401 Kreisen. Eigentlich reihen wir also die gleiche Abbildung für verschiedene Jahre hintereinander. Statisch also:

```{r}
Landkreise_merged %>% 
  filter(!is.na(BIP)) %>% 
  filter(!is.na(Arbeitslosenquote)) %>% 
  ggplot(aes(x = BIP, y = Arbeitslosenquote)) +
  geom_point() +
  facet_wrap(~Jahr)
```

# (1) *Zustände* mit <code>transition_states()</code>

## Minimalbeispiel

In der Minimalversion müssen wir nur eine Zeile ändern. In <code>transition_states</code> wird der *Animationszustand* eingefügt, in unserem Fall die Beobachtungsjahre.

```{r}
Landkreise_merged %>% 
  filter(!is.na(BIP)) %>% 
  filter(!is.na(Arbeitslosenquote)) %>% 
  ggplot(aes(x = BIP, y = Arbeitslosenquote)) +
  geom_point() +
  transition_states(states = Jahr) 
```


## Dynamische Beschriftungen mit <code>{closest_state}</code>

AHA! Es bewegt sich was! Wir wissen allerdings nicht wirklich, was sich tut. Um besser zu verstehen, was die verschiedenen Zustände darstellen, können wir dynamische Labels verwenden. Innerhalb der geschweiften Klammern wird dann der jeweilige *Animationszustand* angezeigt. <code>{closest_state}</code> kann zum Beispiel in die (Unter)überschrift einer Abbildung eingefügt werden. Das Schöne an <code>gganimate</code> ist es, dass die <code>ggplot</code> weitestgehend übernommen werden kann.

```{r}
Landkreise_merged %>% 
  filter(!is.na(BIP)) %>% 
  filter(!is.na(Arbeitslosenquote)) %>% 
  ggplot(aes(x = BIP, y = Arbeitslosenquote)) +
  geom_point() +
  transition_states(states = Jahr) +
  labs(subtitle = "Jahr: {closest_state}") #<--nimmt Werte aus states-Argument vom transition_states()
```

Die Übergänge sind noch etwas zittrig. Die Übergangszeiten lassen sich als Argumente von <code>transtion_states()</code> anpassen. <code>transtion_length</code> gibt die relative Zeit der Animation an, die für Übergänge verwendet werden soll und <code>transtion_lenth</code> die Zeit, die für die Zustände verwendet wird. Deutlich wird die Funktionsweise, wenn wir weniger *Zustände* nutzen. 

```{r}
Landkreise_merged %>% 
  filter(Jahr %in% c(2000, 2017)) %>% #nur auf Start und Endjahr filtern
  ggplot(aes(x = BIP, y = Arbeitslosenquote)) +
  geom_point() +
  transition_states(states = Jahr,
                    transition_length = 9, #9/10 der Zeit für Übergänge
                    state_length = 1) + #1/10 für Zustände
  labs(subtitle = "Jahr: {closest_state}") #<--nimmt Werte aus states-Argument vom transition_states()
```

## Übergänge gestalten mit <code>ease_aes()</code>

Mit <code>ease_aes()</code> lassen sich Übergänge noch ansprechender gestalten. Standardmäßig sind die Übergänge <code>linear</code>. Es stehen aber zahlreiche andere Optionen zur Verfügung, wie z.B. <code>elastic</code>, <code>bounce</code> oder <code>exponential</code>. 

Zusätzlich können die Übergänge durch ein Suffix weiter angepasst werden. Dabei gibt es drei Optionen, von denen **mindestens eine** gewählt werden muss. 

* <code>-in</code> Standardfall.
* <code>-out</code> Umgekehrtes Verhalten.
* <code>-in-out</code> In der ersten Hälfte des Übergangs Standardfall, in der zweiten umgekehrt.

```{r}
Landkreise_merged %>% 
  filter(Jahr %in% c(2000, 2017)) %>% #nur auf Start und Endjahr filtern
  ggplot(aes(x = BIP, y = Arbeitslosenquote)) +
  geom_point() +
  transition_states(states = Jahr) +
  ease_aes("elastic-in-out") +
  labs(subtitle = "Jahr: {closest_state}") #<--nimmt Werte aus states-Argument vom transition_states()
```






